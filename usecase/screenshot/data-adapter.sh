#!/usr/bin/env bash
# Data Adapter Script for CIS PAM Capture Agent
# Purpose: Convert user_credentials_clean.json to bash variables for termshot.sh
# Output: termshot-data.sh (sourceable bash script with arrays)
# Author: PAM Automation Team
# Version: 1.0

# Smart bash version check
if [[ -n "${BASH_VERSINFO:-}" ]]; then
    if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
        for bash_path in /opt/homebrew/bin/bash /usr/local/bin/bash /usr/bin/bash; do
            if [[ -x "$bash_path" ]]; then
                BASH_VER=$("$bash_path" --version 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+' | head -1 | cut -d. -f1)
                if [[ -n "$BASH_VER" ]] && [[ "$BASH_VER" -ge 4 ]]; then
                    exec "$bash_path" "$0" "$@"
                    exit $?
                fi
            fi
        done
        echo "âŒ ERROR: Bash 4.0+ required (current: ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]})"
        echo "ðŸ’¡ Install: brew install bash"
        exit 1
    fi
fi

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${2:-$NC}${1}${NC}"
}

error_exit() {
    log "âŒ ERROR: $1" "$RED"
    exit 1
}

# Configuration
JSON_FILE="${1:-user_credentials_clean.json}"
OUTPUT_FILE="termshot-data.sh"

# Check if JSON file exists
if [[ ! -f "$JSON_FILE" ]]; then
    error_exit "JSON file not found: $JSON_FILE"
fi

# Check if jq is installed
if ! command -v jq &>/dev/null; then
    log "ðŸ“¦ Installing jq..." "$CYAN"
    if command -v apt-get &>/dev/null; then
        sudo apt-get update -qq && sudo apt-get install -y jq 2>&1 | grep -v "^Reading" || true
    elif command -v yum &>/dev/null; then
        sudo yum install -y jq -q || true
    else
        error_exit "Cannot install jq. Please install manually."
    fi
    log "âœ… jq installed successfully" "$GREEN"
fi

# Validate JSON format
if ! jq empty "$JSON_FILE" 2>/dev/null; then
    error_exit "Invalid JSON format in: $JSON_FILE"
fi

# Validate JSON structure
if ! jq -e '.users and .ip_mappings' "$JSON_FILE" >/dev/null 2>&1; then
    error_exit "Invalid JSON structure (missing users or ip_mappings)"
fi

log "ðŸ”„ Processing $JSON_FILE..." "$BLUE"

# Start generating output file
cat > "$OUTPUT_FILE" << 'EOF_HEADER'
#!/usr/bin/env bash
# Generated by data-adapter.sh
# DO NOT EDIT MANUALLY
# This file contains parsed data from user_credentials_clean.json

EOF_HEADER

# Extract unique IPs from ip_mappings
log "ðŸ“‹ Extracting IP addresses..." "$CYAN"
IPS=$(jq -r '.ip_mappings | keys[]' "$JSON_FILE" | sort -V)
IP_COUNT=$(echo "$IPS" | wc -l | tr -d ' ')

if [[ -z "$IPS" ]] || [[ "$IP_COUNT" -eq 0 ]]; then
    log "âš ï¸  WARNING: No IPs found in JSON file" "$YELLOW"
    echo "declare -a TARGET_IPS=()" >> "$OUTPUT_FILE"
else
    # Generate TARGET_IPS array
    echo "# Array of all IPs to process" >> "$OUTPUT_FILE"
    echo -n "TARGET_IPS=(" >> "$OUTPUT_FILE"
    FIRST=1
    for ip in $IPS; do
        if [[ $FIRST -eq 1 ]]; then
            echo -n "\"$ip\"" >> "$OUTPUT_FILE"
            FIRST=0
        else
            echo -n " \"$ip\"" >> "$OUTPUT_FILE"
        fi
    done
    echo ")" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    
    log "âœ… Found $IP_COUNT IP(s)" "$GREEN"
fi

# Generate associative arrays for each IP
log "ðŸ‘¥ Building user mappings per IP..." "$CYAN"

echo "# Associative array: IP -> space-separated usernames" >> "$OUTPUT_FILE"
echo "# Note: Arrays must be pre-declared in parent script" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "# Associative array: IP -> grep pattern for logs" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "# Associative array: IP -> chage command chain" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

USER_COUNT=0

for ip in $IPS; do
    # Get usernames for this IP (array format)
    USERS=$(jq -r --arg ip "$ip" '.ip_mappings[$ip][]?' "$JSON_FILE" 2>/dev/null | tr '\n' ' ' | sed 's/ $//')
    
    if [[ -z "$USERS" ]]; then
        log "  âš ï¸  No users found for IP: $ip" "$YELLOW"
        continue
    fi
    
    # Count users for this IP
    IP_USER_COUNT=$(echo "$USERS" | wc -w | tr -d ' ')
    USER_COUNT=$((USER_COUNT + IP_USER_COUNT))
    
    # Generate IP_USERS mapping
    echo "IP_USERS[\"$ip\"]=\"$USERS\"" >> "$OUTPUT_FILE"
    
    # Generate grep pattern (pipe-separated)
    GREP_PATTERN=$(echo "$USERS" | tr ' ' '|')
    echo "IP_GREP_PATTERN[\"$ip\"]=\"$GREP_PATTERN\"" >> "$OUTPUT_FILE"
    
    # Generate chage command chain with || true
    CHAGE_CMD=""
    FIRST_USER=1
    for user in $USERS; do
        if [[ $FIRST_USER -eq 1 ]]; then
            CHAGE_CMD="chage -l $user || true"
            FIRST_USER=0
        else
            CHAGE_CMD="$CHAGE_CMD && chage -l $user || true"
        fi
    done
    echo "IP_CHAGE_CMD[\"$ip\"]=\"$CHAGE_CMD\"" >> "$OUTPUT_FILE"
    
    log "  âœ“ IP: $ip â†’ $IP_USER_COUNT user(s): $USERS" "$GREEN"
    echo "" >> "$OUTPUT_FILE"
done

# Add helper function to get user count for an IP
cat >> "$OUTPUT_FILE" << 'EOF_HELPER'

# Helper function: Get user count for an IP
get_user_count() {
    local ip="$1"
    echo "${IP_USERS[$ip]}" | wc -w | tr -d ' '
}

# Helper function: Check if IP exists
ip_exists() {
    local ip="$1"
    [[ -n "${IP_USERS[$ip]:-}" ]]
}

# Note: Arrays must be declared in parent scope before sourcing this file
# declare -a TARGET_IPS
# declare -A IP_USERS IP_GREP_PATTERN IP_CHAGE_CMD
EOF_HELPER

# Summary
log "" 
log "âœ… Data adapter completed successfully!" "$GREEN"
log "ðŸ“Š Summary:" "$BLUE"
log "   - Total IPs: $IP_COUNT" "$CYAN"
log "   - Total unique users across all IPs: $USER_COUNT" "$CYAN"
log "   - Output file: $OUTPUT_FILE" "$CYAN"
log ""
log "ðŸ’¡ Usage: source $OUTPUT_FILE" "$YELLOW"

# Make output file executable
chmod +x "$OUTPUT_FILE"

exit 0
